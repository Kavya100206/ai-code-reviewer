/**
 * GitHub Comment Formatter
 * Formats AI review results as markdown for GitHub PR comments
 */

/**
 * Format AI review as markdown comment
 * 
 * @param {Object} review - AI review object from reviewCodeWithAI()
 * @param {Object} prData - PR data for context
 * @returns {string} Markdown formatted comment
 */
export function formatReviewComment(review, prData) {
    let markdown = '';

    // Header
    markdown += '## AI Code Review\n\n';

    // Summary
    markdown += `**Summary:** ${review.summary}\n\n`;

    // Issues section
    if (review.issues && review.issues.length > 0) {
        markdown += `### Issues Found (${review.issues.length})\n\n`;

        review.issues.forEach((issue, index) => {
            // Severity icon
            const severityIcon = getSeverityIcon(issue.severity);
            const severityLabel = issue.severity.toUpperCase();

            markdown += `#### ${index + 1}. ${severityIcon} ${severityLabel} - ${issue.type}\n\n`;

            // File and line
            if (issue.file) {
                markdown += `**File:** \`${issue.file}\``;
                if (issue.line) {
                    markdown += ` (Line ${issue.line})`;
                }
                markdown += '\n\n';
            }

            // Title
            if (issue.title) {
                markdown += `**${issue.title}**\n\n`;
            }

            // Description
            if (issue.description) {
                markdown += `${issue.description}\n\n`;
            }

            // Suggestion
            if (issue.suggestion) {
                markdown += `> **Suggestion:** ${issue.suggestion}\n\n`;
            }

            markdown += '---\n\n';
        });
    } else {
        markdown += '### No Issues Found\n\n';
        markdown += 'Great job! The code looks good.\n\n';
    }

    // Positives section
    if (review.positives && review.positives.length > 0) {
        markdown += '### Positive Highlights\n\n';
        review.positives.forEach(positive => {
            markdown += `- ${positive}\n`;
        });
        markdown += '\n';
    }

    // Footer
    markdown += '---\n';
    markdown += '*This review was generated by AI. Please review suggestions carefully.*\n';

    return markdown;
}

/**
 * Get icon for severity level
 */
function getSeverityIcon(severity) {
    const icons = {
        critical: 'ðŸ”´',
        high: 'ðŸŸ ',
        medium: 'ðŸŸ¡',
        low: 'ðŸ”µ'
    };
    return icons[severity] || 'âšª';
}

/**
 * Format review as simple text (fallback if markdown fails)
 */
export function formatReviewText(review) {
    let text = 'AI Code Review\n\n';
    text += `Summary: ${review.summary}\n\n`;

    if (review.issues && review.issues.length > 0) {
        text += `Issues Found: ${review.issues.length}\n\n`;
        review.issues.forEach((issue, index) => {
            text += `${index + 1}. [${issue.severity}] ${issue.title}\n`;
            text += `   ${issue.description}\n\n`;
        });
    }

    return text;
}

export default formatReviewComment;
